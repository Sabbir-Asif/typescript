Great question! Let's explore the **runtime behavior** of `enum`, `const enum`, and `union types` in TypeScript. This is key to understanding how your code behaves **after it's compiled** to JavaScript and how each construct affects **performance, file size, and runtime safety**.

---

# ğŸ” Runtime Behavior of `enum`, `const enum`, and `union types`

| Feature                  | `enum`                        | `const enum`                      | Union Type (`'A' | 'B'`)         |
|--------------------------|-------------------------------|-----------------------------------|----------------------------------|
| Exists at runtime?       | âœ… Yes                         | âŒ No (inlined at compile time)   | âŒ No                             |
| Adds to JS output?       | âœ… Yes (generates an object)   | âŒ No                              | âŒ No                             |
| Supports reverse mapping | âœ… Yes (only numeric enums)    | âŒ No                              | âŒ No                             |
| Type-safe?               | âœ… Yes                         | âœ… Yes                             | âœ… Yes                            |
| Best for...              | External APIs, runtime checks | Performance, inlining constants   | Pure type safety, simple cases   |

---

## ğŸ”· 1. `enum` (Regular Enum)

### âœ… Exists at Runtime

When you define a regular `enum`, it is **compiled into a JavaScript object**.

```ts
enum Direction {
  Up,
  Down,
  Left,
  Right,
}
```

### ğŸ›  Compiled JavaScript:

```js
var Direction;
(function (Direction) {
  Direction[(Direction["Up"] = 0)] = "Up";
  Direction[(Direction["Down"] = 1)] = "Down";
  Direction[(Direction["Left"] = 2)] = "Left";
  Direction[(Direction["Right"] = 3)] = "Right";
})(Direction || (Direction = {}));
```

### ğŸ“Œ Behavior:
- **Bidirectional mapping**: You can do `Direction[0]` â†’ `"Up"` or `Direction.Up` â†’ `0`
- **Code size**: It adds an actual object to your output bundle
- **Runtime use**: You can inspect, loop through, or reflect on the enum

---

## ğŸ”¶ 2. `const enum`

### ğŸš« Does *not* exist at runtime

```ts
const enum Direction {
  Up,
  Down,
  Left,
  Right,
}
```

### ğŸ›  Compiled JavaScript:

```js
let move = 2; // Direction.Left is replaced by 2 directly
```

### ğŸ“Œ Behavior:
- **Inlined** values: Every use of `Direction.Left` becomes `2` at compile time
- **No object generated**, so itâ€™s faster and smaller
- **No runtime reflection**, reverse mapping not possible
- Requires full enum definition to be available during compilation
- Not allowed with dynamic or computed values

âœ… **Best for performance-critical or memory-sensitive applications**

---

## ğŸ”´ 3. Union Types

```ts
type Direction = "Up" | "Down" | "Left" | "Right";
```

### ğŸ›  Compiled JavaScript:

```js
// Nothing at all!
```

### ğŸ“Œ Behavior:
- **Completely erased** from JavaScript
- Only exists at **compile time**
- âœ… TypeScript uses these for **type checking only**
- âŒ No runtime validation, you must manually validate if needed

âœ… **Best for modeling string literals without adding any runtime weight**

---

## ğŸ” Summary Table

| Feature               | `enum`                        | `const enum`                    | Union Type                     |
|------------------------|-------------------------------|----------------------------------|--------------------------------|
| Runtime object         | âœ… Yes                         | âŒ No                             | âŒ No                           |
| In JS output           | âœ… Yes                         | âŒ No                             | âŒ No                           |
| Reverse lookup         | âœ… Yes (numeric enums only)    | âŒ No                             | âŒ No                           |
| Performance            | ğŸ”» Slower (object access)     | ğŸš€ Fastest (no object, inlined)  | ğŸš€ Fastest (no output at all)  |
| Bundle size impact     | ğŸ”º Bigger                      | âœ… Smaller                        | âœ… Smallest                    |
| Runtime inspection     | âœ… Can reflect/iterate         | âŒ Cannot reflect                 | âŒ Cannot reflect              |

---

## ğŸ§  When to Use What?

| Use Case | Recommendation |
|----------|----------------|
| You need runtime inspection, reflection, or dynamic logic | Use **`enum`** |
| You want performance and no runtime cost | Use **`const enum`** |
| You only need compile-time type checking | Use **`union types`** |

---

## ğŸš¨ Gotchas

- `const enum` canâ€™t be used with dynamic imports or isolated modules unless `preserveConstEnums` is false.
- Union types are **type-safe but not self-documenting**â€”they don't exist at runtime.
- Enums can cause unexpected behavior in tree-shaking and optimization.

---

Would you like me to generate a **visual diagram or cheatsheet** showing this comparison?